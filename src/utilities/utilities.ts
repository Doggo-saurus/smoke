import { Player, Theme } from "@owlbear-rodeo/sdk";
import { Constants } from "./constants";

export function GetGUID(): string
{
    let d = new Date().getTime();
    const guid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) =>
    {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
    });
    return guid;
}

export function Debounce(func: () => any, delay: number): () => void
{
    let timeoutId: number;

    return function debounced(): void
    {
        clearTimeout(timeoutId);

        timeoutId = setTimeout(() =>
        {
            func();
        }, delay);
    };
}

export function isObjectEmpty(obj: Record<string, any>): boolean
{
    for (const key in obj)
    {
        if (obj.hasOwnProperty(key))
        {
            return false;
        }
    }
    return true;
}

export function TestEnvironment()
{
    try
    {
        localStorage.setItem("STORAGECHECK", "test");
    }
    catch (error)
    {
        const storageWarningElement = document.getElementById("localStorageWarning")!;
        storageWarningElement.innerText = "Local Storage disabled. Some features will not function.";
    }
}

export function CheckPlayerProcess(players: Player[])
{
    const processedIndicator = document.getElementById("processedIndicator") as HTMLButtonElement;
    const playersProcessed = players.every(player => player.metadata[`${Constants.EXTENSIONID}/processed`] === true);
    if (playersProcessed)
    {
        processedIndicator.style.backgroundColor = "green";
        processedIndicator.title = "Everything looks good.";
    }
    else
    {
        processedIndicator.style.backgroundColor = "red";
        processedIndicator.title = "A player is having trouble processing/seeing.";
    }
}

export function InvertColor(hex: any)
{
    const bw = true;
    if (hex.indexOf('#') === 0)
    {
        hex = hex.slice(1);
    }
    // convert 3-digit hex to 6-digits.
    if (hex.length === 3)
    {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    if (hex.length !== 6)
    {
        throw new Error('Invalid HEX color.');
    }
    var r: any = parseInt(hex.slice(0, 2), 16),
        g: any = parseInt(hex.slice(2, 4), 16),
        b: any = parseInt(hex.slice(4, 6), 16);
    if (bw)
    {
        // https://stackoverflow.com/a/3943023/112731
        return (r * 0.299 + g * 0.587 + b * 0.114) > 186
            ? '#000000'
            : '#FFFFFF';
    }
    // invert color components
    r = (255 - r).toString(16);
    g = (255 - g).toString(16);
    b = (255 - b).toString(16);
    // pad each with zeros and return
    return "#" + padZero(r) + padZero(g) + padZero(b);
}

function padZero(str: any, len: number = 0)
{
    len = len || 2;
    var zeros = new Array(len).join('0');
    return (zeros + str).slice(-len);
}

export function SetThemeMode(theme: Theme, document: Document): void
{
    const darkThemeMq = window.matchMedia("(prefers-color-scheme: dark)");

    const darkTheme = darkThemeMq.matches ? "dark" : "light";
    const lightTheme = darkThemeMq.matches ? "light" : "dark";

    for (var s = 0; s < document.styleSheets.length; s++)
    {
        for (var i = 0; i < document.styleSheets[s].cssRules.length; i++)
        {
            let rule = document.styleSheets[s].cssRules[i] as CSSMediaRule;

            if (rule && rule.media && rule.media.mediaText.includes("prefers-color-scheme"))
            {
                if (theme.mode == "LIGHT")
                {
                    rule.media.appendMedium(`(prefers-color-scheme: ${darkTheme})`);

                    if (rule.media.mediaText.includes(lightTheme))
                    {
                        rule.media.deleteMedium(`(prefers-color-scheme: ${lightTheme})`);
                    }
                }
                else if (theme.mode == "DARK")
                {
                    rule.media.appendMedium(`(prefers-color-scheme: ${lightTheme})`);

                    if (rule.media.mediaText.includes(darkTheme))
                    {
                        rule.media.deleteMedium(`(prefers-color-scheme: ${darkTheme})`);
                    }
                }
            }
        }
    }
}

export function evaluateMathExpression(command: string): number | string
{
    // Remove the "/math" part and any leading/trailing whitespaces
    const expression = command.replace("/math", "").trim();

    // Validate the expression
    const validExpressionRegex = /^[-+*/()\d\s]+$/;
    if (!validExpressionRegex.test(expression))
    {
        return "That's not math. (Invalid expression.)";
    }

    try
    {
        // Evaluate the expression using the eval() function
        const result = eval(expression);
        return `The answer to ${expression} is ${result}.`;
    }
    catch (e)
    {
        return `Error: ${e}`;
    }
}